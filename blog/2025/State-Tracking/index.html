<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> State Tracking with Sequence Models | Stephan Cho </title> <meta name="author" content="Stephan Cho"> <meta name="description" content="Analyzing the theoretical limits of sequence models for state tracking and compositional reasoning"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/al-folio/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/al-folio/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/al-folio/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/al-folio/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/al-folio/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://alshedivat.github.io/al-folio/blog/2025/State-Tracking/"> <script src="/al-folio/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/al-folio/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" integrity="sha256-q9ba7o845pMPFU+zcAll8rv+gC+fSovKsOoNQ6cynuQ=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css" integrity="sha256-Oppd74ucMR5a5Dq96FxjEzGF7tTw2fZ/6ksAqDCM8GY=" crossorigin="anonymous" media="screen and (prefers-color-scheme: light)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" integrity="sha256-nyCNAiECsdDHrr/s2OQsp5l9XeY2ZJ0rMepjCT2AkBk=" crossorigin="anonymous" media="screen and (prefers-color-scheme: dark)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/css/diff2html.min.css" integrity="sha256-IMBK4VNZp0ivwefSn51bswdsrhk0HoMTLc2GqFHFBXg=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script src="/al-folio/assets/js/distillpub/template.v2.js"></script> <script src="/al-folio/assets/js/distillpub/transforms.v2.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "State Tracking with Sequence Models",
            "description": "Analyzing the theoretical limits of sequence models for state tracking and compositional reasoning",
            "published": "June 29, 2025",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/al-folio/"> <span class="font-weight-bold">Stephan</span> Cho </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/al-folio/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/al-folio/blog/">blog </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>State Tracking with Sequence Models</h1> <p>Analyzing the theoretical limits of sequence models for state tracking and compositional reasoning</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#what-is-state-tracking">What is State Tracking?</a> </div> <div> <a href="#introduction-to-circuit-complexity">Introduction to Circuit Complexity</a> </div> <div> <a href="#state-tracking-and-circuit-complexity">State Tracking and Circuit Complexity</a> </div> <div> <a href="#linear-rnns">Linear RNNs</a> </div> <div> <a href="#conclusion">Conclusion</a> </div> </nav> </d-contents> <p>Large Language Models can perform impressive tasks such as storytelling, instruction following, and code generation. These capabilities seem to suggest an ability to maintain a complex internal “state,” keeping track of context and dependencies over long sequences. And yet, their performance often falters on precise compositional tasks, such as logical puzzles and arithmetic, which involve keeping track of intermediate results <d-cite key="dziri2023faithfatelimitstransformers"></d-cite>.</p> <p>Most LLMs are based on the transformer architecture, as it performs well on language modeling. However, under a standard conjecture in computational complexity theory, transformers may not be well suited to the state tracking task.</p> <p>We’ll define state tracking, introduce relevant concepts from circuit complexity, analyze how Transformers and RNNs perform, discuss limitations, and explore potential solutions.</p> <h2 id="what-is-state-tracking">What is State Tracking?</h2> <p>Formally, we can consider state tracking as simulating the transition function of a semiautomaton, following <d-cite key="liu2023transformerslearnshortcutsautomata"></d-cite>:</p> <p>Let \(\mathcal{A} = (Q,\Sigma, \delta)\) be a <em>semiautomaton</em>, which consists of a finite set of states \(Q\), an input alphabet \(\Sigma\), and a transition function \(\delta : Q \times \Sigma \rightarrow Q.\) We can think of \(\sigma \in \Sigma\) as actions or transformations that update the state from \(q\) to \(q^\prime=\delta(q, \sigma)\). Given a starting state \(q_0\) and an input sequence \(\sigma_{1:T} = (\sigma_1,\sigma_2,...,\sigma_T)\) we get a sequence \((q_1,...,q_T)\) by the action \(q_t=\delta (q_{t-1},\sigma_t)\) for \(t=1,...,T.\) This defines a mapping \(\mathcal{A}_{T,q_0}: \Sigma^T \rightarrow Q^T\) by \(\mathcal{A}_{T,q_0} (\sigma_1,\sigma_2,...,\sigma_T) = (q_1,...,q_T).\)</p> <p>We say that a function \(f:\Sigma^T \rightarrow Q^T\) <em>simulates</em> \(\mathcal{A}\) if for all input sequences \(\sigma_{1:T}\), \(f(\sigma_{1:T}) = \mathcal{A}_{T,q_0}(\sigma_{1:T})\). Usually, \(f\) is chosen to be a sequence model like a Transformer or RNN.</p> <p>To simplify our discussion, we will define the <em>state tracking problem</em> as the task of finding the final state, given the initial state \(q_0\) and an input sequence \((\sigma_1,\sigma_2,...,\sigma_T)\). We focus on this final state computation to understand the limits of models tackling this problem.</p> <h2 id="introduction-to-circuit-complexity">Introduction to Circuit Complexity</h2> <p>To analyze these limits, we can use the framework of <em>circuit complexity</em>, which measures the resources required to compute a function using a family of boolean circuits, denoted \(\{C_n\}^\infty _{n=0}.\) This framework usually considers functions with output in \(\{ 0, 1\}\), so computations need to be reformulated into a decision problem. In the context of our state tracking problem, for input size \(T\), we want a function \(f\) such that \(f(\sigma_1,\sigma_2,...,\sigma_T) =1\) if \(\pi_T\left(\mathcal{A}_{T,q_0}(\sigma_1,\sigma_2,...,\sigma_T) \right)=q_T\) and \(0\) otherwise.</p> <p><strong>Definition:</strong> A <em>boolean circuit</em> \(C_n\) is a function \(\{0,1\}^n \rightarrow \{0,1\}\), represented by a directed acyclic graph with 3 types of nodes:</p> <ul> <li> <strong>Input nodes:</strong> \(n\) nodes with an in-degree of \(0\), corresponding to the \(n\) input bits.</li> <li> <strong>Gate nodes:</strong> Nodes with positive in-degree and out-degree, representing intermediate computations. Each is labeled with a boolean gate (e.g., AND, OR, NOT, MAJORITY).</li> <li> <strong>Output node:</strong> A single node with an out-degree of 0, representing the circuit’s output.</li> </ul> <p>We analyze a family of boolean circuits \(\{C_n\}_{n=0}^\infty\) to describe how computational resources scale with the input size \(n\). The number of nodes in \(C_n\) is its <strong>size</strong>, \(s(n)\), and the length of the longest path from an input to the output is its <strong>depth</strong>, \(d(n)\).</p> <p><strong>Definition.</strong> Let \(\Sigma\) be a non-empty set, called an alphabet. Consider the free monoid construction, \(\Sigma^*=\cup _{i\geq 0} \Sigma^i\) where \(\Sigma^i\) denotes i-fold concatenation and \(\Sigma^0 = \{ \epsilon \}\) is the set containing the empty string. \(\Sigma^*\) is the set of strings of finite length generated by the alphabet \(\Sigma,\) including the empty string \(\epsilon\). The operator \(^*\) is called the Kleene star operator. A <em>formal language</em> is a subset \(L \subseteq \Sigma^*\). We are interested in binary languages, \(L \subseteq \{0,1\}^*\) and in particular its <em>characteristic function</em> \(f_L: \{0,1\}^* \rightarrow \{0,1\},\) where \(f_L(x) =1\) if and only if \(x \in L.\)</p> <p><strong>Example:</strong> Consider the language \(L_{PARITY}=(11)^*=\{\epsilon, 11,1111,....\}\) which contains all strings of \(1\)’s of even length. The characteristic function is \(f(1^k)=1\) if \(k\) is even, and \(f(1^k)=0\) if \(k\) is odd.</p> <p><strong>Definition:</strong> A family of boolean circuits \(\{C_n\}_{n=0}^\infty\) <em>recognizes a language</em> \(L\) if for any \(n\geq 0\) and string \(x\in\{0,1\}^n,\) \(x\in L\) if and only if \(C_n(x)=1.\) We can also formulate this using the characteristic function: for any \(x\in \{0,1\}^n,\) \(f_L(x)=C_n(x)\).</p> <p><strong>Definition:</strong> A function \(f: \{0,1\}^* \rightarrow \{0,1\}\) is in \(TC^0\) if there exists a polynomial \(p\), a constant \(d\), and a family of boolean circuits \(\{C_n\}_{n=0}^\infty\) such that:</p> <ul> <li>each circuit is made of AND, OR, NOT and MAJORITY gates of unbounded fan in,</li> <li>each \(C_n\) is of size \(p(n)\),</li> <li>has constant depth \(d\)</li> <li>for an input of size \(n\), \(x \in \{0,1\}^n\), we have \(f(x)=C_n(x)\).</li> </ul> <p><strong>Definition:</strong> A function \(f: \{0,1\}^* \rightarrow \{0,1\}\) is in \(NC^1\) if there exists a polynomial \(p\), a constant \(d\), and a family of boolean circuits \(\{C_n\}_{n=0}^\infty\) such that:</p> <ul> <li>each circuit is made of AND, OR, NOT gates of fan in 2,</li> <li>each \(C_n\) is of size \(p(n)\),</li> <li>\(C_n\) has logarithmic depth \(O(\log(n))\),</li> <li>for an input of size \(n\), \(x \in \{0,1\}^n\), we have \(f(x)=C_n(x)\).</li> </ul> <p><strong>Definition:</strong> a language \(L\) is in \(TC^0\) (or \(NC^1\)) if its characteristic function \(f_L\) is in the corresponding class.</p> <p>The definitions above can be extended to functions with multiple output bits: let \(in(n), out(n)\) be non-negative, non-decreasing, polynomially bounded functions, and consider boolean circuits \(C_n:\{0,1\}^{in(n)} \rightarrow \{0,1\}^{out(n)}\). For example, \(n\)-bit addition is a function \(f:\{0,1\}^{2n}\rightarrow \{0,1\}^{n+1}\) <d-cite key="doi:10.1137/0215070"></d-cite>.</p> <p>Although state tracking and related problems of interest will be represented with binary valued functions, some intermediate computations will involve multiple bit outputs. The main point is that some functions can be computed with constant depth circuits (in \(TC^0\)), while others need logarithmic depth (in \(NC^1\)). <strong>Examples:</strong></p> <ul> <li>\(n\) bit addition, multiplication and division is in \(TC^0\)</li> <li>\(L_{PARITY}\) is in \(TC^0\)</li> <li>A computation with fixed sized input is vacuously in \(TC^0\). \(k \times k\) matrix multiplication for fixed \(k\) is in \(TC^0\).</li> </ul> <p>A standard fact in circuit complexity theory is that \(TC^0 \subseteq NC^1\). It’s an open problem whether the containment is strict, although it is believed that \(TC^0 \neq NC^1\).</p> <h2 id="state-tracking-and-circuit-complexity">State Tracking and Circuit Complexity</h2> <p>Note that the state tracking problem can be solved by a circuit in \(NC^1\) by formulating it as a matrix multiplication problem. For each state \(q\in Q\), we can encode it into a \(|Q|\)-dimensional one-hot vector. Each input symbol \(\sigma \in \Sigma\) gives us a map \(\delta(-, \sigma):Q \rightarrow Q\) which we can think of as a matrix \(M_\sigma \in \{0,1\}^{|Q| \times |Q| }\). We have \([M_\sigma]_{i,j}=1_{\{ \delta(e_j , \sigma) = e_i \}}\) and \(M_\sigma\) acts on state vectors by left multiplication. This matrix multiplication can be performed by a constant depth circuit, and we can apply a divide and conquer approach to perform all the multiplications in a \(O(\log T)\) depth circuit. Therefore, state tracking is in \(NC^1\).</p> <p>Using log precision, Transformers are in \(TC^0\) <d-cite key="merrill2023parallelismtradeofflimitationslogprecision"></d-cite>. If we believe \(TC^0 \neq NC^1\), then a constant depth transformer would not be able to solve the state tracking problem for arbitrary sequence length. This could explain why transformers fail to generalize to longer sequences and harder problems. If we allow variable depth based on input size, we can construct a transformer with \(O(\log T)\) layers to solve the state tracking problem of length \(T\) <d-cite key="liu2023transformerslearnshortcutsautomata"></d-cite>. While a transformer performing next token prediction may not be as expressive as an RNN, allowing it to output intermediate tokens can increase expressivity. A transformer model performing chain of thought for \(O(n)\) intermediate steps <d-cite key="merrill2024expressivepowertransformerschain"></d-cite> can simulate \(NC^1\) circuits (see also <d-cite key="li2024chainthoughtempowerstransformers"></d-cite>).</p> <p>Recurrent Neural Networks (RNNs) can solve state tracking in a single layer. An RNN maps a sequence \((x_1,...,x_T)\) to \((y_1,...y_T)\) and is given by the recurrence \(h_{t+1}=g(h_t, x_t), \ y_t=dec(h_t,x_t)\) where \(g\) and \(dec\) are learnable, nonlinear functions. Let \(x_t=\sigma_t\) and \(h_t =q_{t-1}\) be the 1-hot vector representing the state. \(g(-,x_t)\) can simulate the state transition function \(\delta (- ,\sigma_t)\) (<d-cite key="merrill2025illusionstatestatespacemodels"></d-cite>, theorem 5.1). In particular, even if we constrain \(g(-,x_t)\) to be a linear transformation, it can represent the state transition matrix \(M_{\sigma_t}\), and so linear RNNs with general state matrix can also solve the state tracking problem.</p> <p>Although state tracking and other relevant problems lie in \(NC^1\), we will focus on a specific synthetic task, to which any other task in \(NC^1\) can be reduced.</p> <h3 id="the-word-problem-a-proxy-for-nc1">The Word Problem: A Proxy for \(NC^1\)</h3> <p><em>Word problem for a finite group</em> \(G:\) given a sequence \((x_1,x_2,...x_n) \in G^n\) and \(y \in G\), determine if \(x_1 x_2...x_n = y\). It is equivalently formulated as: given a sequence \((g_1,...,g_n) \in G^n\), determine if \(g_1g_2,...,g_n = e\).</p> <ul> <li>For solvable groups, like \(A_4\) and \(\mathbb{Z}_{60}\), this is in \(TC^0\) (via Khoan Rhoades theorem).</li> <li>For nonsolvable groups (such as \(A_5\) and \(S_5\)), it is \(NC^1\) complete.</li> </ul> <p>Barrington’s theorem <d-cite key="BARRINGTON1989150"></d-cite> states that any circuit in \(NC^1\), with input size \(n\), can be reduced to a circuit calculating the word problem on \(A_5\) of polynomial length in \(n\). (Thms 1 and 5). This means solving the \(A_5\)​ word problem is, in a sense, as hard as any other problem in \(NC^1\), including state tracking. We will therefore use the \(A_5\)​ word problem as a benchmark for evaluating model capabilities.</p> <h3 id="no-of-layers-vs-sequence-length">No. of Layers vs Sequence Length</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/al-folio/assets/img/2025-07-04-State-Tracking/graphs_3tasks-480.webp 480w,/al-folio/assets/img/2025-07-04-State-Tracking/graphs_3tasks-800.webp 800w,/al-folio/assets/img/2025-07-04-State-Tracking/graphs_3tasks-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/al-folio/assets/img/2025-07-04-State-Tracking/graphs_3tasks.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Now let’s show some empirical results showing how transformers do on this problem. For \(G \in \{\mathbb{Z}_{60}, A_4 \times \mathbb{Z}_5, A_5 \}\), we train llama based transformers to acheive &gt;90% validation accuracy, following the experiment from <d-cite key="merrill2025illusionstatestatespacemodels"></d-cite>. We directly encode group elements into tokens instead of tokenizing its string based representation.</p> <p>Here, the standard task is: fix an maximum sequence length \(n\). For \(k\leq n\), given an input sequence \((x_1,...,x_k)\in G^k\), we want our model to calculate \(f_\theta(x_1,...,x_k)=y_k\) where \(y_k=x_1 \cdot ...\cdot x_k\).</p> <p>The chain of thought task is: \(f_\theta (x_1,...,x_n, c, y_1,...,y_k)=y_{k+1}\) where \(c\) is a placeholder token. For \(k=0\) we have \(f_\theta (x_1,...,x_n, c)=y_{1}\). In particular, in <d-cite key="li2024chainthoughtempowerstransformers"></d-cite> they construct a 2 layer transformer that can solve the word problem on \(S_5\).</p> <p>A similar idea to CoT is pursued in <d-cite key="liu2023transformerslearnshortcutsautomata"></d-cite>, called “scratchpad training” where the output tokens are interleaved with the input tokens \((x_1,y_1,x_2,y_2,...,x_n,y_n)\) and the model is trained autoregressively. Intuitively, these tasks are easier because the model can look at its intermediate results to perform the next calculation, avoiding the need for logarithmic depth.</p> <p>In the figure, we see that for \(A_5\), the transformer model needs more layers to handle longer sequences, while the LSTM model can predict with just one layer. The transformer model in Chain of Thought mode also only needs 1 layer to solve this task. Interestingly, for the transformer model, the word problem for $A_4\times \mathbb{Z}_5$ is almost as hard as the $A_5$ word problem, requiring more layers as the sequence length increases.</p> <h2 id="linear-rnns">Linear RNNs</h2> <p>Linear Recurrent Neural Networks are motivated by the goal of developing fast, efficient sequence models capable of performance comparable to Transformers, particularly in language modeling. Unlike a traditional RNN, the hidden state is updated through an affine transformation. The condition that it’s affine allows us to use parallel associative scan for the forward pass. We’ll follow notation from <d-cite key="grazzi2025unlockingstatetrackinglinearrnns"></d-cite>:</p> <p><strong>Definition:</strong> A linear RNN layer is a function \(f_\theta : \mathbb{R}^l \times \mathbb{C}^{n\times d} \rightarrow \mathbb{R}^l \times \mathbb{C}^{n\times d}\) that maps an input, hidden state pair \((x_t, H_{t-1})\) to output, next hidden state pair \((\hat y_t, H_{t})\) in the following way:</p> \[\begin{gathered} H_t = A(x_t)H_{t-1}+B(x_t),\ \hat y_t = dec(H_t,x_t)\ \text{for } t\in \{ 1,...,T\} \\ H_0 \in\mathbb{C}^{n\times d},\ A:\mathbb{R}^l \rightarrow \mathbb{C}^{n\times n},\ B:\mathbb{R}^l \rightarrow \mathbb{C}^{n\times d},\ dec: \mathbb{C}^{n\times d} \times\mathbb{R}^l \rightarrow \mathbb{R}^p \end{gathered}\] <p>where \(A,B\) and \(dec\) are learnable, and generally nonlinear functions of the network parameters \(\theta\). We can stack multiple layers by feeding the outputs of one layer as the inputs to the next layer. For the rest of this post we will focus on real valued \(A\) and \(B\).</p> <p>The structure of the state transition matrix function \(A\) determines the expressivity of the linear RNN. If we allow \(A\) to be a general real valued matrix, we can simulate a semiautomaton by setting \(A\) to be the state transition matrix. However, we constrain \(A\) in various ways in order to train them efficiently. For stable training, we bound the eigenvalues \(\lvert \lambda_i \rvert \leq 1\). This addresses the gradient exploding problem usually seen with traditional RNNs.</p> <p>Initially, popular linear RNN architectures constrained the matrix \(A\) to being diagonal and with nonnegative eigenvalues. Some examples are Mamba and Gated Linear Attention. It turns out these choices limit the expressivity of the model:</p> <p><strong>Theorem 1:</strong> (from <d-cite key="grazzi2025unlockingstatetrackinglinearrnns"></d-cite>) For a finite precision LRNN with finitely many layers, if the eigenvalues of each \(A(x)\) is nonnegative for all x, then it cannot can solve parity for arbitrary input lengths. In other words, it cannot recognize the language \((11)^*\)</p> <p><em>Proof idea:</em> Let’s consider a single layer LRNN, as multiple layers can be handled by induction. For simplicity, we will assume all arithmetic operations will be handled in \(\mathbb{R},\) with infinite precision, and then the cast the result into finite precision \(\mathbb{D}\), which is a finite subset of \(\mathbb{R}.\) The closed form expression for the hidden state \(H_k\) is</p> \[H_k = \left( \prod^k_{i=1} A(x_i)\right)H_0+ \sum^k_{i=1}\left( \prod^k_{j=i+1}A(x_j) \right)B(x_i)\] <p>where we set \(\prod^k_{j=k+1}A(x_j) = I\). On an input sequence \(x_1,...,x_k=(1)^k\), we get</p> \[H_k = A(1)^k H_0 + \sum^{k}_{i=1}A(1)^{i-1}B(1)\] <p>Now write \(A(1)=PJP^{-1}\) in its Jordan canonical form and consider its largest eigenvalue \(\lambda_1\) in \(J\). After analyzing the different cases \(\lambda_1 \in [0,1), \lambda_1 = 1\), and \(\lambda_1 &gt;1\), there exists \(\tau\) such that for all \(k \geq \tau\) and a fixed matrix \(M,\) the resulting matrix product becomes constant after taking finite precision: \(cast(A(1)^kM)=\hat M\). Thus for \(k\) large enough, \(cast(H_k) = cast(H_{k+1})\) and the LRNN cannot distinguish between \((1)^k\) and\((1)^{k+1}\).</p> <p><strong>Theorem 2:</strong> (from <d-cite key="grazzi2025unlockingstatetrackinglinearrnns"></d-cite>): For a finite precision LRNN with finitely many layers, if the eigenvalues of each \(A(x)\) is real for all \(x\), then it cannot can solve modular counting \(\mod m\), where \(m\) is not a power of \(2\), for arbitrary input lengths. In other words, it cannot recognize the language \((1^m)^*\). Note that for a real valued triangular matrix, all of its eigenvalues are real, so a LRNN with triangular state matrix cannot solve modular counting. This motivates the need for general, non-triangular state matrices.</p> <p><em>Proof idea:</em> It’s very similar to the proof of theorem 1, although with negative eigenvalues, a single layer LRNN will have its hidden state alternate between \(2\) values, for sequence length \(k\) large enough. For \(L\) layers, the function \(k \mapsto \hat H_k\) will be periodic with period \(2^L\), so if \(m \neq 2^n\) for some \(n\), then the LRNN cannot recognize modular counting.</p> <p>Architectures that allow for negative eigenvalues and non-triangular matrices include modifications of DeltaNet and DeltaProduct, as well as RWKV v7. In DeltaProduct, the state-transition matrix \(A(x_{i})\) is defined as the product of \(n_h\) generalized Householder matrices: \(A(x_{i}) = \prod_{j=1}^{n_{h}}(I - \beta_{i,j}k_{i,j}k_{i,j}^{\top}).\) To allow for negative eigenvalues, they replace $\beta_{i,j}$ with $2\beta_{i,j}$, where $\beta_{i,j}\in [0,1]$ is an input dependent gating factor. This construction enables a rank \(n_h\)​ update to the hidden state at each step. Since a \(k\times k\) permutation matrix can be formed by a product of \(k-1\) GH matrices, a single layer DeltaProduct model with \(n_h=k-1\) and \(n=k\) can solve the word problem of the permutation group on \(k\) elements (see theorem 3 in <d-cite key="grazzi2025unlockingstatetrackinglinearrnns"></d-cite>): simply choose generalized Householder matrices such that \(A(x_i)\in \mathbb{R}^{k \times k}\) is the permutation matrix representing \(x_i\) and \(H_i \in \mathbb{R}^{k\times 1}\) is the resulting permutation on \(k\) elements after \(i\) permutation operations.</p> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/al-folio/assets/img/2025-07-04-State-Tracking/A5-480.webp 480w,/al-folio/assets/img/2025-07-04-State-Tracking/A5-800.webp 800w,/al-folio/assets/img/2025-07-04-State-Tracking/A5-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/al-folio/assets/img/2025-07-04-State-Tracking/A5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/al-folio/assets/img/2025-07-04-State-Tracking/S5-480.webp 480w,/al-folio/assets/img/2025-07-04-State-Tracking/S5-800.webp 800w,/al-folio/assets/img/2025-07-04-State-Tracking/S5-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/al-folio/assets/img/2025-07-04-State-Tracking/S5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figures from <d-cite key="siems2025deltaproductimprovingstatetrackinglinear"></d-cite>. Comparing accuracy vs sequence length for modified DeltaProduct models with $n_h$ GH matrices and coefficients $2\beta_{i,j}$. </div> <p>In <d-cite key="siems2025deltaproductimprovingstatetrackinglinear"></d-cite>, they empirically show that the word problem on a permutation group on \(5\) elements can be solved with a single layer DeltaProduct with \(4\) GH matrices. Interestingly, the model with \(2\) \(GH\) matrices is able to learn permutations from \(A_5\) by exploiting the structure of the group.</p> <h2 id="conclusion">Conclusion</h2> <p>While a transformer model has a hard time solving compositional tasks like word problems, chain of thought allows it to reuse previous calculations for the next decoding step. On the other hand, linear RNNs, when the state matrix is expressive enough, can solve the word problem without chain of thought. It would be interesting to see if LLMs based on linear RNNs are better at solving compositional tasks in natural language with a shorter chain of thought than current transformer based reasoning LLMs.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/al-folio/assets/bibliography/2025-07-04-State-Tracking.bib"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'stephan271c/stephan271c.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Stephan Cho. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/al-folio/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/al-folio/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/js/diff2html-ui.min.js" integrity="sha256-eU2TVHX633T1o/bTQp6iIJByYJEtZThhF9bKz/DcbbY=" crossorigin="anonymous"></script> <script defer src="/al-folio/assets/js/diff2html-setup.js?80a6e52ce727518bbd3aed2bb6ba5601" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js" integrity="sha256-MgH13bFTTNqsnuEoqNPBLDaqxjGH+lCpqrukmXc8Ppg=" crossorigin="anonymous"></script> <script defer src="/al-folio/assets/js/leaflet-setup.js?b6313931e203b924523e2d8b75fe8874" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script defer src="/al-folio/assets/js/chartjs-setup.js?183c5859923724fb1cb3c67593848e71" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script defer src="/al-folio/assets/js/echarts-setup.js?738178999630746a8d0cfc261fc47c2c" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script defer src="/al-folio/assets/js/vega-setup.js?7c7bee055efe9312afc861b128fe5f36" type="text/javascript"></script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/al-folio/assets/js/typograms.js?062e75bede72543443762dc3fe36c7a5"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/al-folio/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/al-folio/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/al-folio/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/al-folio/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/al-folio/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/al-folio/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/al-folio/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/al-folio/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/al-folio/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/al-folio/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/al-folio/assets/js/search-data.js"></script> <script src="/al-folio/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>